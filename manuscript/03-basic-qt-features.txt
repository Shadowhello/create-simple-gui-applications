# Basic Qt Features

Welcome to your first steps in create graphical applications! In this chapter you will
be introduced to the key basic features of Qt (PyQt) that you will find yourself using
in any applications you create. We will develop a series of small applications,
adding (and removing!) features step-by-step. Use the code given as your guide, and 
feel free to experiment around it — particularly with reference to the [Qt Documentation][qt5-doc].

T> ### Source Code
T>
T> If you get stuck at any time, the source code is available to download from:  
T> [http://download.martinfitzpatrick.name/create-simple-gui-applications/all_the_source.zip]
T> [all-the-source-download]

## My first Window

So, lets get started by creating our very first windowed application. Before getting
the window on the screen, there are a few key concepts to introduce about how
applications are organised in the Qt world. If you're already familiar with event
loops you can safely skip to the next section.

### The Event loop and `QApplication`

The core of every Qt Applications is the `QApplication` class. Every application
needs one — and only one — `QApplication` object to function. This object holds
the *event loop* of your application — the core loop which governs all user 
interaction with the GUI.

Each interaction with your application — whether a press of a key, click of a mouse,
or mouse movement — generates an *event* which is placed on the *event queue*.
In the event loop, the queue is checked on each iteration and if a waiting event
is found, the event and control is passed to the specific *event handler* for the event. 
The event handler deals with the event, then passes control back to the event
loop to wait for more events. There is only *one* running event loop per 
application.


I> ### Key Points
I>
I> - QApplication holds the Qt event loop
I> - One QApplication instance required
I> - You application sits waiting in the event loop until an action is taken
I> - There is only *one* event loop


### Creating your App

So, lets create your first application! To start create a new Python file — you 
can call it whatever you like (e.g. `MyApp.py`).

W> ### Backup!
W>
W> We'll be editing within this file as we go along, and you may want to come
W> back to earlier versions of your code, so remember to keep regular backups
W> along the way. For example, after each section save a file named `MyApp_<section>.py`

The source code for your very first application is shown below. Type it in verbatim,
and be careful not to make mistakes. If you do mess up, Python should let you know
what's wrong when you run it. If you don't feel like typing it all in, you can 
[download the source code][all-the-source-download].

{pagebreak}

<<(code/creating_a_window_1.py)

{pagebreak}

Let's go through the code line by line. 

We start by importing the PyQt5 classes that we need for the application,
from the `QtWidgets`, `QtGui` and `QtCore` submodules.

I> This kind of global import `from <module> import *` is generally
I> frowned upon in Python. However, in this case we know that the 
I> PyQt classnames don't conflict with one another, or with Python itself.
I> Importing them all saves a lot of typing, and helps with PyQt4 compatibility.

Next we create an instance of `QApplication`, passing in `sys.arg` (which contains 
command line arguments). This allows us to pass command line arguments to our
application. If you know you won't be accepting command line arguments you can
pass in an empty list instead, e.g.

    app = QApplication([])

Finally, we call `app..exec_()` to start up the event loop.

I> The underscore is there because `exec` is a reserved word in Python and can’t
I> be used as a function name. PyQt5 handles this by appending an underscore to the 
I> name used in the C++ library. You'll also see it for `.print_()`.

So, lets launch your application. You can run it from the command line like any
other Python script, for example:

    python MyApp.py
    
Or, for Python 3:

    python3 MyApp.py

The application should run without errors, yet there will be no indication of 
anything happening, aside from perhaps a busy indicator. This is completely 
normal — we haven't told Qt to create a window yet!

Every application needs at least one `QMainWindow`, though you can have more
than one if you ned to. However, no matter how many you have, your application
will always exit when the last main window is closed.

Let's add a `QMainWindow` to our application.

{pagebreak}

<<(code/creating_a_window_2.py)

{pagebreak}

I> ### `QMainWindow`
I>
I> - Main focus for user of your application
I> - Every application needs at least one (...but can have more)
I> - Application will exit when last main window is closed

If you launch the application you should now
see your main window. Notice that Qt automatically creates a window with the normal
window decorations, and you can drag it around and resize it like any normal window.

E> ### I can't see my window!
E> 
E> You must *always* call  `.show()` on a newly created `QMainWindow` as they
E> are created invisible by default.

Congratulations — you've created your first Qt application! It's not very
interesting at the moment, so lets add some content to the window.

If you want to create a custom window, the best approach is to subclass 
`QMainWindow` and then include the setup for the window in the `__init__`
block. This allows the window behaviour to be self contained. So 
lets add our own subclass of `QMainWindow` — we can call it `MainWindow` to
keep things simple.

{pagebreak}

<<(code/creating_a_window_end.py)

{pagebreak}

We write the `__init__` block with a small bit of boilerplate to take
the arguments (none currently) and pass them up to the `__init__` of
the parent `QMainWindow` class.

I> When you subclass a Qt class you must *always* call the super
I> `__init__` function to allow Qt to set up the object.

Next we use `.setWindowTitle()` to change the title of our main window.

Then we add our first widget — a `QLabel` — to the middle of the window.
This is one of the simplest widgets available in Qt. You create the object
by passing in the text that you want the widget to display.

We set the alignment of the widget to the center, so it will show up in
the middle of the window.


T> The Qt namespace (`Qt.`) is full of all sorts of attributes that you can use
T> to customise and control Qt widgets. We’ll cover that a bit more later,
T> [it’s worth a look][qt5-doc-qt-namespace].

Finally, we call `.setCentralWidget()` on the the window. This is a
`QMainWindow` specific function that allows you to set the widget that
goes in the middle of the window.

If you launch your application you should see your window again, but this time
with the `QLabel` widget in the middle. 

I> ### Hungry for widgets?
I>
I> We'll cover more widgets in detail shortly
I> but if you're impatient and would like to jump ahead you can take a look at the
I> [QWidget documentation][qt5-doc-widgets]. Try adding the different widgets to your window!


In this section we've covered the `QApplication` class, the `QMainWindow`
class, the event loop and experimented with adding a simple widget to a window. In the next
section we'll take a look at the mechanisms Qt provides for widgets and windows to 
communicate with one another and your own code.

{icon=floppy-o}
G> Save a copy of your file as `MyApp_window.py` as we'll need it again later.


## Signals, Slots, Events

As already described, every interaction the user has with a Qt application causes
an Event. There are multiple types of event, each representing a difference
type of interaction — e.g. mouse or keyboard events.

Events that occur are passed to the event-specific handler on the widget where
the interaction occurred. For example, clicking on a widget will cause a
`QMouseEvent` to be sent to the `.mousePressEvent` event handler on the widget.
This handler can interrogate the event to find out information, such as 
what triggered the event and where specifically it occurred.

You can intercept events by subclassing and overriding the handler function on
the class, as you would for any other function. You can choose to filter,
modify, or ignore events, passing them through to the normal handler for 
the event by calling the parent class function with `super()`.

    class CustomButton(Qbutton)

        def keyPressEvent(self, e):
            # My custom event handling
            super(CustomButton, self).keyPressEvent(e)

However, imagine you want to catch an event on 20 different buttons. Subclassing
like this now becomes an incredibly tedious way of catching, interpreting
and handling these events.
    
    class CustomButton99(Qbutton)

        def keyPressEvent(self, e):
            # My custom event handling
            super(CustomButton99, self).keyPressEvent(e)

Thankfully Qt offers a neater approach to receiving notification of 
things happening in your application: *Signals*.


### Signals

Instead of intercepting raw events, signals allow you to 'listen' for
notifications of specific occurrences within your application. While
these can be similar to events — a click on a button — they can also
be more nuanced — updated text in a box. Data can also be sent 
alongside a signal - so as well as being notified of the updated text 
you can also receive it.

The receivers of signals are called *Slots* in Qt terminology. A number of
standard slots are provided on Qt classes to allow you to wire together
different parts of your application. However, you can also use any Python
function as a slot, and therefore receive the message yourself.

{icon=floppy-o}
G> Load up a fresh copy of `MyApp_window.py` and save it under a new name for this section.

#### Basic signals

First, let's look at the signals available for our `QMainWindow`. You can
find this information in the [Qt documentation][qt-doc-qmainwindow].
Scroll down to the Signals section to see the signals implemented for 
this class. 

![Qt 5 Documentation — QMainWindow Signals](images/qtdoc-signals-qmainwindow.png)

As you can see, alongside the two `QMainWindow` signals, there are 
4 signals inherited from `QWidget` and 2 signals inherited from `Object`.
If you click through to the `QWidget` signal documentation you can see a
`.windowTitleChanged` signal implemented here. Next we'll demonstrate that
signal within our application. 

![Qt 5 Documentation — Widget Signals](images/qtdoc-signals-qwidget.png)


{pagebreak}

<<(code/signals_slots_and_events_1.py)

{pagebreak}

We start by creating an function that will behave as a ‘slot’ for our
signals.

Then we use .connect on the `.windowTitleChanged` signal. We pass the
function that we want to be called with the signal data. In this case
the signal sends a string, containing the new window title.

If we run that, we see that we receive the notification that the window
title has changed.

#### Customising signal data

—— As you use signals you’ll often find that you want to be able to
customise the data that is sent with them. Unfortunately there is no way
to do this in Qt directly, but we can exploit some features of Python to
make it work.

To start with, lets see how to send less data. For example we’ll create
a function that accepts two parameters, with default values. However,
neither of these is a string. How can we connect our
`.windowTitleChanged` signal to this function?

We can do this by using a wrapper function, or a lambda. When the signal is
emitted this wrapper function will be called and can add or remove data
from the signal as required, before passing it on to the real slot.

So, for example, to discard data from a signal we could use the following 
construction. The lambda accepts a single parameter `x`, then discards it
calling the *real* target `fn` with no parameters:

    lamba x: fn()

If we want to send *more* data we can use a similar construction, but 
instead of discarding a parameter we add another. For example:

    lamba x: fn(x, some_more_data)




However, lets try that again with a loop. Here we’re going to use a
layout to create a list of widgets, don’t worry about that it’ll be
explained later.

You’ll notice that clicking on all of the widgets gives the same result?

So, what can we do? If we pass the extra data in as a named parameter to
the lambda, we create a new namespace and voila it works.

    lambda x, data=data: fn(x, data)


E> You *must* use named parameters
E>
E> 
E> That’s because the some_more_data value in the lambda is referencing the
E> loop namespace. When it’s triggered it returns the last value that the
E> variable had in that namespace.


So, now you should be able to pass just about anything to any function
using signals! The final code now looks like this:

{pagebreak}

<<(code/signals_slots_and_events_2.py)

{pagebreak}

#### Custom Signals

The final bit of signals we’re going to cover is custom signals. These
allow you to use the Qt event loop to send data around your application.
It’s a great way to keep your app modular and responsive.

Signals must be defined on the class. You pass in the type that will be
sent with the signal when creating it. You can send any Python type,
including multiple types, and compound types (e.g. dictionaries, lists).

Then, you can connect and use your signal just as normal.


### Events

Next, let’s take a quick look at events. Thanks to signals, for most
purposes you can happily avoid using events in Qt, but it’s important
to understand how they work for when they are neccessary.

As an example, we're going to intercept the `.contextMenuEvent` on 
`QMainWindow`. This event is fired whenever a context menu is 
*about to be* shown, and is passed a single value `event` of type
`QContextMenuEvent`.

To intercept the event, we simply override the object method with our
new method of the same name. So in this case we can create a method
on our `MainWindow` subclass with the name `contextMenuEvent` and it
will receive all events of this type.

    def contextMenuEvent(self, event):
        print("Context menu event!")

If you add the above method to your `MainWindow` class and run your 
program you will discover that right-clicking in your window now
displays the message in the print statement.

Sometimes you may wish to intercept an event, yet still trigger 
the default (parent) event handler. You can do this by calling the
event handler on the parent class using `super` as normal for
Python class methods.

    def contextMenuEvent(self, event):
        print("Context menu event!")
        super(self, MainWindow).contextMenuEvent(event)

This allows you to propogate events up the object hierarchy, handling only
those parts of an event handler that you wish to.


However, in Qt there is another type of event hierarchy, constructed 
around the UI relationships. Widgets that are added to a layout, within 
another widget, may opt to pass their events to their UI parent. 
In complex widgets with multiple sub-elements this can allow for 
delegation of event handling to the containing widget for certain events.

However, if you have dealt with an event and do not want it
to propogate in this way you can flag this by calling .accept() on the event.

    class CustomButton(Qbutton)
    
        def event(self, e):
            e.accept()

Alternatively, if you do want it to propogate calling .ignore() will
achieve this.

    class CustomButton(Qbutton)
    
        def event(self, e):
            e.ignore()

In this section we've covered signals, slots and events. We've demonstrated
some simple signals, including how to pass less and more data using lambdas.
We've created custom signals, and shown how to intercept events, pass on
event handling and use `.accept()` and `.ignore()` to hide/show events
to the UI-parent widget. In the next section we will go on to take 
a look at two common features of the GUI — toolbars and menus.


## Actions, Toolbars and Menus

{icon=floppy-o}
G> Load up a fresh copy of `MyApp_window.py` and save it under a new name for this section.


tbc.
### Actions

QAction
Customizable with labels, status tooltips, and icons
Provides .hovered, .triggered and .toggled signals
Can be added to toolbars and menus


### Toolbars

{pagebreak}

<<(code/toolbars_and_menus_1.py)

{pagebreak}

[toolbar image]
Toolbars
Bar of icon buttons at the top of your application

Icons, toggles, drop-down menus
Any widget can be inserted

[qtdoc-signals]


[qtdoc-buttonstyle]

{pagebreak}

<<(code/toolbars_and_menus_2.py)

{pagebreak}

### Menus

Menus 
Drop-down menus at the top of your application
Standards include File, Edit
Nested, hierarchical
Keyboard shortcuts and icons

{pagebreak}

<<(code/toolbars_and_menus_3.py)

{pagebreak}

[menu-image]

[keysequence]


QToolbar
QAction
Icons
Status tips
Signals .triggered and .toggled
QMenu
Including accelerator keys for Windows
Keyboard shortcuts

The completed code, showing the toolbar buttons and menus is shown below.

{pagebreak}

<<(code/toolbars_and_menus_end.py)

{pagebreak}

{icon=floppy-o}
G> Save a copy of your file as `MyApp_menus.py` as we'll need it again later.


## Widgets

In Qt (and most User Interfaces) ‘widget’ is the name given to a
component of the UI that the user can interact with. User interfaces are
made up of multiple widgets, arranged within the window.

Qt comes with a large selection of widgets available, and even allows
you to create your own custom and customised widgets.

{icon=floppy-o}
G> Load up a fresh copy of `MyApp_window.py` and save it under a new name for this section.

### Big ol' list of widgets

A full list of widgets is available on the Qt documentation. But lets
have a look at them quickly.

{pagebreak}

<<(code/widgets_list.py)

{pagebreak}

To do this we’re going to take the skeleton of our application and
replace the `QLabel` with a `QWidget`. This is the generic form of a Qt
widget.

Here we’re not using it directly. We apply a list of widgets - in a
layout, which we will cover shortly - and then add the `QWidget` as the
central widget for the window. The result is that we fill the window
with widgets, with the `QWidget` acting as a container.

Note that it’s possible to use this `QWidget` layout trick to create
custom compound widgets.

Lets have a look at the widgets. From top to bottom

`QCheckbox` - a checkbox `QComboBox` - a dropdown list box `QDateEdit` &
`QDateTimeEdit` - for editing dates and datetimes `QDial` - rotateable dial
`QDoubleSpinbox` - a number spinner for floats `QFontComboBox` - a list of
fonts `QLCDNumber` - a quite ugly LCD display `QLabel` - just a label, not
interactive `QLineEdit` - enter a line of text `QProgressBar` - a progress
bar `QPushButton` - a button `QRadioButton` - a toggle set `QSlider` - a
slider `QSpinBox` - an integer spinner `QTimeEdit` - for editing times

There are actually more widgets than this, but they don’t fit so well!
You can see them all by checking the documentation. Here we’re going to
take a closer look at the a subset of the most useful.

{pagebreak}

#### QLabel

We'll start the tour wit `QLabel`, arguably one of the simplest widgets
available in the Qt toolbox. This is a simple one-line piece of text
that you can position in your application. You can set the text by 
passing in a str as you create it, or by using the `.setText()` method.

    widget = QLabel("Hello")

Or:

    widget = QLabel("1") # The label is created with the text 1
    widget.setText("2") # The label now shows 2
    
You can also adjust font parameters, such as the size of the font or
the alignment of text in the widget.

<<(code/widgets_1.py)

I> ## Font tips
I> 
I> Note that if you want to change the properties of a widget font it
I> is usually better to get the *current* font, update it and then 
I> apply it back. This ensures the font face remains in keeping with 
I> the desktop conventions.

The alignment is specified by using a flag from the `Qt.` namespace.
The flags available for horizontal alignment are:


| Flag            | Behaviour                   
|-----------------|-------------------------------------------------|
| Qt.AlignLeft    | Aligns with the left edge.                      |
| Qt.AlignRight   | Aligns with the right edge.                     |
| Qt.AlignHCenter | Centers horizontally in the available space.    |
| Qt.AlignJustify | Justifies the text in the available space.      |

The flags available for vertical alignment are:


| Flag            | Behaviour                   
|-----------------|-------------------------------------------------|
| Qt.AlignTop     | Aligns with the top.                            |
| Qt.AlignBottom  | Aligns with the bottom.                         |
| Qt.AlignVCenter | Centers vertically in the available space.      |


You can combine flags together using pipes (`|`), however note that you
can only use vertical or horizontal alignment flag at a time.
There is also a shorthand flag that centers in both directions simultaneously:

    Qt.AlignCenter = Qt.AlignVCenter | Qt.AlignHCenter


Weirdly, you can also use `QLabel` to display an image using `.setPixmap()`. 
This accepts an *pixmap*, which you can create by passing an image filename
to `QPixmap`. In the example files provided with this book you can find
a file `hrh.jpg` which you can display in your window as follows:


<<(code/widgets_2.py)


    label.setPixMap(QPixmap('hrh.jpg'))
    

{pagebreak}

![HRH Queen Lizzy (by NASA/Bill Ingalls — Public domain.](images/hrh.jpg)


God Save the Queen. By default the image scales while maintaining its
aspect ratio. If you want it to stretch and scale to fit the window completely
you can set `.setScaledContents(True)` on the `QLabel`.


    label.setScaledContents(True)


{pagebreak}

#### QCheckBox

Next `QCheckBox()`. Pretty simple, click it to check it.

<<(code/widgets_3.py)

You can also set it checked using `.setChecked(True)`

…or using `.setCheckState` and `Qt.Checked`

Checkboxes also support tri-state, that is being on, off, or neither. To
set this use `Qt.PartiallyChecked`

Lets look at the signals. We can connect to stateChanged to receive the
current state.

Here we can see that checked = 2, unchecked = 0, and partially checked
=1. You don’t need to remember these values, the `Qt.Checked` namespace
variable == 2 for example.

If you set the value to `Qt.PartiallyChecked` the checkbox will become
tristate. You can also `.setTriState(True)` to set tristate support on a
fully-checked or unchecked checkbox.


{pagebreak}

#### QComboBox


Next is the `QComboBox` a drop-down list. You can add items to the list
using addItems and passing in a Python list of strings.

<<(code/widgets_4.py)


The `currentIndexChanged` signal informs you when the selected item is
updated.

By default it passes the index of the item selected.

When connecting to the signal you can also request the string version of
the signal by using [str] (think of the signal as a dict) to get that
specific version.

{pagebreak}

#### QListBox

Next `QListBox`. It’s very similar to `QComboBox`, differing mainly in the
signals available.

<<(code/widgets_5.py)

`QListBox` offers an `currentItemChanged` signal which sends the `QListItem`
(the element of the list box), and a `currentTextChanged` signal which
sends the text.

{pagebreak}

#### QLineEdit

`QLineEdit` is a box for entering a single line of text. You can type
anything you like.

<<(code/widgets_6.py)

You can set a maximum length for the text with `.setMaxLength`.

You can add placeholder text to be shown when nothing is entered.

You can also set the text box to be read only, so it cannot be edited.

There is a signal to detect when return has been pressed, when the text
selection has changed.

For when the text in the box has been edited and when it has been
changed. The distinction here is between user edits and programmatic
changes. The `textEdited` signal is only sent when the user edits text. —

{pagebreak}

#### QSpinBox

`QSpinBox` provides a small numerical input box with arrows to increase
and decrease the value. `QSpinBox` supports integers.

<<(code/widgets_7.py)


You can set the range using `setMinimum` and `setMaximum`, or `setRange` to
set both simultaneously.

Prefixes and suffixes can be added to the number, for example currency
markers or units.

The size of the step determines how much the value increases or
decreases for each arrow button click.

A valueChanged signal emits the current value whenever it updates.

A string version of this same signal sends the value, but as a string
including the prefix and suffix.

The related widget, `QDoubleSpinBox`, is basically identical, except 
that is supports floats.


{pagebreak}

#### QSlider

`QSlider` is a slider functions much like a `QDoubleSpinBox`

There is an additional sliderMoved signal that is triggered whenever the
slider moves position and a sliderPressed signal that emits whenever the
slider is clicked.

<<(code/widgets_8.py)


{pagebreak}

#### QDial

Finally `QDial` is a rotateable widget that functions just like the
slider, but appears as an analogue dial.

<<(code/widgets_9.py)

— That’s the end of this brief tour through the Qt widgets available in
PyQt. To see the full list of available widgets and their signals and
attributes, take a look at the Qt documentation.



## Layouts


{icon=floppy-o}
G> Load up a fresh copy of `MyApp_window.py` and save it under a new name for this section.

Linear position
`QHBoxLayout` (horizontal)
`QVBoxLayout` (vertical)
Grid position
`QGridLayout`
Stacked (z) in front of one another
QStackedLayout


So you have a window, and you want to put something in it. But how do
you tell Qt where to place it? Layouts.

It is worth noting that you can actually design and lay out your
interface graphically using the Qt Designer. However, in this tutorial
we will be exploring using code only. It’s a better way to understand
how these things work.

There are three positional layouts available in Qt. The `VBoxLayout`,
`QHBoxLayout` and `QGridLayout`. There is also `QStackedLayout` which allows
you to place widgets one on top of the other.

With `QVBoxLayout` you arrange widgets one above the other linearly.
Adding a widget adds it to the bottom of the column.

![A QHBoxLayout, filled from top to bottom.](images/vboxlayout.png)

`QHBoxLayout` is the same, except moving horizontally. Adding a widget
adds it to the right hand side.

![A QHBoxLayout, filled from left to right.](images/hboxlayout.png)

`QGridLayout` allows you to specify using row,column indices where to
place the widget.

![A QGridLayout showing the grid positions for each location.](images/gridlayout1.png)

Usefully, for `QGridLayout` you don't need to fill all the positions in the grid.

![A QGridLayout with unfilled slots.](images/gridlayout2.png)

Finally, `QStackedLayout` allows you to place widgets one in front of the
other. You could use this for drawing layers in a graphics application,
or for imitating a tab-like interface. Note there is also `QStackedWidget`
which is a container widget that works in exactly the same way. This is
useful if you want to add a stack directly to a `QMainWindow` with
`.setCentralWidget`.

![QStackedLayout — in use only the uppermost widget is visible, which is by default the first widget added to the layout.](images/qstackedlayout1.png)

![QStackedLayout, with the 2nd (1) widget selected and brought to the front ](images/qstackedlayout2.png)


To demonstrate this we’re going to create a custom widget, with a solid
color background. Don’t worry about this for now, it’s just for
demonstration purposes.

{pagebreak}

<<(code/layout_1.py)

{pagebreak}

Once it’s complete we add it to the mainwindow using `.setCentralWidget`
and we get a solid red window.

So lets add some things to a `QVBoxLayout`. We still need to add a widget
to the mainwindow so we create a empty `QWidget` and set the layout on
that. Our coloured widgets will arrange themselves in the layout,
contained within the `QWidget` in the window.

First lets just add the red widget again.

{pagebreak}

<<(code/layout_2.py)

{pagebreak}

Notice the border, this is the layout spacing.

We can add two more colours.

As we add widgets they line themselves up vertically in the order they
are added.

If we change the `QVBoxLayout` to a `QHBoxLayout` the boxes now flow left to
right.

    layout = QHBoxLayout()

You can nest widgets inside one another using addLayout. Let’s add a
`QVBoxLayout` into the main `QHBoxLayout`. If we add some widgets to the
`QVBoxLayout`, they’ll be arranged vertically in the first slot of the
parent layout.

{pagebreak}

<<(code/layout_4.py)

{pagebreak}

You can set the spacing around the layout using `.setContentMargins`.

…or set the spacing between elements using `.setSpacing`.

    layout1.setContentsMargins(0,0,0,0)
    layout1.setSpacing(20)

As useful as they are, if you try and using `QVBoxLayout` and `QHBoxLayout` for
laying out multiple elements, e.g. for a form, you’ll find it very
difficult to ensure differently sized widgets line up. The solution to
this is `QGridLayout`.

`QGridLayout` allows you to position items specifically in a grid. You
specify row and column positions for each widget. You can skip elements,
and they will be left empty.

{pagebreak}

<<(code/layout_6.py)

{pagebreak}

—

The final layout we’ll cover is the `QStackedLayout`. As described, this
layout allows you to position elements directly in front of one another.
You can then select which widget you want to show.

{pagebreak}

<<(code/layout_7.py)

{pagebreak}

This is exactly how tabbed views work - only one view (‘tab’) is show at
any one time.

You can add elements to a `QStackedLayout` as normal. By default the
latest-added widget is shown.

You can choose to show another widget by calling `.setCurrentIndex()` or
`.setCurrentWidget()`.

I’m going to create a quick demo to show how you could use
`QStackedLayout` to provide a tab-like interface.

{pagebreak}

<<(code/layout_8.py)

{pagebreak}

But… helpfully. Qt actually provide a built-in TabWidget that provides
this kind of layout out of the box - albeit in widget form.

I’ll re-create the demo using `QTabWidget` and demonstrate some features.

{pagebreak}

<<(code/layout_9.py)

{pagebreak}


So that’s it!

In this lesson we introduced the 3 main classes of positional layouts
`QHBoxLayout`, `QVBoxLayout`, `QGridLayout` and the special layout
`QStackedLayout`. Until next time!



## Dialogs

{icon=floppy-o}
G> Load up a fresh copy of `MyApp_menus.py` and save it under a new name for this section.


Get input from the user
Settings, configuration
OK and Cancel buttons
“Special dialogs”
e.g. file open, save

[dialog]

So, time for another standard feature of GUIs - dialog boxes.

In Qt, Dialog boxes are handled by the `QDialog` class. Creating a dialog
box is incredibly easy, so lets do it.

Here I’m adding it to the function we added to the toolbar button click
- meaning any toolbar button clicking will show a dialog.

We create the dialog instance, giving it self - `QMainWindow` - as a
parent. This will make the dialog a modal window of QMainWindow (meaning
it will completely block interaction with it).

To start the dialog we use exec_() - just like we did for the event
loop. That’s not a coincidence. When you exec the QDialog an entirely
new event loop - specific for the dialog - is created. Remember I said
there can only be one Qt event loop running at any time? I meant it. The
QDialog completely blocks your application execution. Remember that!

So, anyway! It works. We click the buttona and we get a modal window.

Ok. So lets make it a bit more interesting and set the dialog title.

Great. But what about some buttons?

To extend it further we’re going to need to subclass the QDialog type,
just like we did for `QMainWindow`. Init super init.

Dialog box buttons are defined in a very specific way. You can ignore
this and use `QButton`, but by following this standard you ensure your
buttons will obey the host operating system layouts (Ok on left vs.
right for example). You don’t want to mess with that unless you want to
annoy people.

So to define buttons we use namespace attributes from `QDialogButtonBox`.
To get multiple buttons we just OR them together (using a pipe).

We create a buttonbox instance, passing in the button definition we’ve
created.

We then connect the .accepted and .rejected signals to the handlers for
`.accept()` and `.reject()` on the `QDialog` (that we’ve inhereted).

So lets try that!

Now, to see the buttons we need to add them to a layout and set the
layout on the `QDialog`.

…and there you go. A dialog with some buttons in it. Of course you can
go ahead and add any other content you like to the layout as normal.

So, that’s it! A short and simple introduction to dialogs in Qt.






[qt5-doc]: http://doc.qt.io/qt-5/  "Qt5 Documentation"
[qt5-doc-widgets]: http://doc.qt.io/qt-5/widget-classes.html#basic-widget-classes "Basic Qt Widgets"
[qt5-doc-qt-namespace]: http://doc.qt.io/qt-5/qt.html
[qt-doc-qmainwindow]: http://doc.qt.io/qt-5/qmainwindow.html
[all-the-source-download]: http://download.martinfitzpatrick.name/create-simple-gui-applications/all_the_source.zip




